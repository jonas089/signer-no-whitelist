{"ast":null,"code":"import _applyDecoratedDescriptor from \"/home/chef/Desktop/signer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor\";\n\nvar _class;\n\nimport { action, computed } from 'mobx';\nimport { FieldState, FormState } from 'formstate';\nimport { valueRequired } from '../../lib/FormValidator';\nlet AccountManager = (_class = class AccountManager {\n  constructor(errors, backgroundManager, appState) {\n    this.errors = errors;\n    this.backgroundManager = backgroundManager;\n    this.appState = appState;\n    this.confirmPasswordForm = new FormState({\n      confirmPasswordField: new FieldState('').validators(valueRequired)\n    });\n  }\n\n  async createNewVault(password) {\n    await this.errors.withCapture(this.backgroundManager.createNewVault(password));\n  }\n\n  async importUserAccount(name, secretKeyBase64, algorithm, backedUp) {\n    return this.backgroundManager.importUserAccount(name, secretKeyBase64, algorithm, backedUp);\n  }\n\n  async removeUserAccount(name) {\n    return this.backgroundManager.removeUserAccount(name);\n  }\n\n  async reorderAccount(startIndex, endIndex) {\n    // the data flow is always from background to frontend.\n    // we need do reorder operations on both background and frontend side,\n    // so that UI won't get jitter\n    const len = this.appState.userAccounts.length;\n\n    if (startIndex < 0 || endIndex < 0 || startIndex >= len || endIndex >= len) {\n      throw new Error('Invalid index number');\n    }\n\n    if (startIndex === endIndex) {\n      return;\n    }\n\n    const removed = this.appState.userAccounts.spliceWithArray(startIndex, 1);\n    this.appState.userAccounts.spliceWithArray(endIndex, 0, removed);\n    return this.backgroundManager.reorderAccount(startIndex, endIndex);\n  }\n\n  switchToAccount(accountName) {\n    return this.backgroundManager.switchToAccount(accountName);\n  }\n\n  get userAccounts() {\n    return this.appState.userAccounts;\n  }\n\n  get isTimeToSecurityCheckup() {\n    return this.appState.isTimeToSecurityCheckup;\n  }\n\n  async resetSecurityCheckup() {\n    return await this.backgroundManager.resetSecurityCheckup();\n  }\n\n  async isBackedUp(alias) {\n    return await this.backgroundManager.isBackedUp(alias);\n  }\n\n  async downloadPemFiles(alias) {\n    // Save the secret and public keys to disk.\n    this.backgroundManager.downloadAccountKeys(alias);\n  }\n\n  async downloadActiveKey() {\n    let userAccount = await this.backgroundManager.getActiveUserAccount(); // Save the secret and public keys to disk.\n\n    this.downloadPemFiles(userAccount.alias);\n  }\n\n  async getActivePublicKeyHex() {\n    return await this.backgroundManager.getActivePublicKeyHex();\n  }\n\n  async getActiveAccountHash() {\n    return await this.backgroundManager.getActiveAccountHash();\n  }\n\n  async getPublicKeyHexByAlias(alias) {\n    return await this.backgroundManager.getPublicKeyHexByAlias(alias);\n  }\n\n  async getAccountHashByAlias(alias) {\n    return await this.backgroundManager.getAccountHashByAlias(alias);\n  }\n\n  async lock() {\n    return this.backgroundManager.lock();\n  }\n\n  async unlock(password) {\n    return this.backgroundManager.unlock(password);\n  }\n\n  get hasCreatedVault() {\n    return this.appState.hasCreatedVault;\n  }\n\n  async resetVault() {\n    return this.backgroundManager.resetVault();\n  }\n\n  get isUnLocked() {\n    return this.appState.isUnlocked;\n  }\n\n  get activeUserAccount() {\n    return this.appState.activeUserAccount;\n  }\n\n  get remainingUnlockAttempts() {\n    return this.appState.unlockAttempts;\n  }\n\n  get isLockedOut() {\n    return this.appState.lockedOut;\n  }\n\n  async resetLockout() {\n    return this.backgroundManager.resetLockout();\n  }\n\n  async startLockoutTimer(timeInMinutes) {\n    return this.backgroundManager.startLockoutTimer(timeInMinutes);\n  }\n\n  get lockoutTimerStarted() {\n    return this.appState.lockoutTimerStarted;\n  }\n\n  get timerDuration() {\n    return this.appState.timerDurationMins;\n  }\n\n  get remainingMins() {\n    return this.appState.remainingMins;\n  }\n\n  async resetLockoutTimer() {\n    return this.backgroundManager.resetLockoutTimer();\n  }\n\n  async renameUserAccount(oldName, newName) {\n    return this.backgroundManager.renameUserAccount(oldName, newName);\n  }\n\n  async confirmPassword(password) {\n    return this.backgroundManager.confirmPassword(password);\n  }\n\n  get confirmPasswordDisabled() {\n    let disabled = !this.confirmPasswordForm.$.confirmPasswordField.$ || !this.confirmPasswordForm.$.confirmPasswordField.hasBeenValidated || this.confirmPasswordForm.$.confirmPasswordField.hasBeenValidated && this.confirmPasswordForm.$.confirmPasswordField.hasError;\n    return disabled;\n  }\n\n  get idleTimeoutMins() {\n    return this.appState.idleTimeoutMins;\n  }\n\n  async configureTimeout(durationMins) {\n    if (durationMins === this.idleTimeoutMins) return;\n    await this.backgroundManager.configureTimeout(durationMins);\n  }\n\n}, (_applyDecoratedDescriptor(_class.prototype, \"userAccounts\", [computed], Object.getOwnPropertyDescriptor(_class.prototype, \"userAccounts\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"isTimeToSecurityCheckup\", [computed], Object.getOwnPropertyDescriptor(_class.prototype, \"isTimeToSecurityCheckup\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"resetSecurityCheckup\", [action], Object.getOwnPropertyDescriptor(_class.prototype, \"resetSecurityCheckup\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"hasCreatedVault\", [computed], Object.getOwnPropertyDescriptor(_class.prototype, \"hasCreatedVault\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"resetVault\", [action], Object.getOwnPropertyDescriptor(_class.prototype, \"resetVault\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"isUnLocked\", [computed], Object.getOwnPropertyDescriptor(_class.prototype, \"isUnLocked\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"activeUserAccount\", [computed], Object.getOwnPropertyDescriptor(_class.prototype, \"activeUserAccount\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"remainingUnlockAttempts\", [computed], Object.getOwnPropertyDescriptor(_class.prototype, \"remainingUnlockAttempts\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"isLockedOut\", [computed], Object.getOwnPropertyDescriptor(_class.prototype, \"isLockedOut\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"resetLockout\", [action], Object.getOwnPropertyDescriptor(_class.prototype, \"resetLockout\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"startLockoutTimer\", [action], Object.getOwnPropertyDescriptor(_class.prototype, \"startLockoutTimer\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"lockoutTimerStarted\", [computed], Object.getOwnPropertyDescriptor(_class.prototype, \"lockoutTimerStarted\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"timerDuration\", [computed], Object.getOwnPropertyDescriptor(_class.prototype, \"timerDuration\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"remainingMins\", [computed], Object.getOwnPropertyDescriptor(_class.prototype, \"remainingMins\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"resetLockoutTimer\", [action], Object.getOwnPropertyDescriptor(_class.prototype, \"resetLockoutTimer\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"confirmPasswordDisabled\", [computed], Object.getOwnPropertyDescriptor(_class.prototype, \"confirmPasswordDisabled\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"idleTimeoutMins\", [computed], Object.getOwnPropertyDescriptor(_class.prototype, \"idleTimeoutMins\"), _class.prototype)), _class);\nexport default AccountManager;","map":{"version":3,"sources":["/home/chef/Desktop/signer/src/popup/container/AccountManager.ts"],"names":["action","computed","FieldState","FormState","valueRequired","AccountManager","constructor","errors","backgroundManager","appState","confirmPasswordForm","confirmPasswordField","validators","createNewVault","password","withCapture","importUserAccount","name","secretKeyBase64","algorithm","backedUp","removeUserAccount","reorderAccount","startIndex","endIndex","len","userAccounts","length","Error","removed","spliceWithArray","switchToAccount","accountName","isTimeToSecurityCheckup","resetSecurityCheckup","isBackedUp","alias","downloadPemFiles","downloadAccountKeys","downloadActiveKey","userAccount","getActiveUserAccount","getActivePublicKeyHex","getActiveAccountHash","getPublicKeyHexByAlias","getAccountHashByAlias","lock","unlock","hasCreatedVault","resetVault","isUnLocked","isUnlocked","activeUserAccount","remainingUnlockAttempts","unlockAttempts","isLockedOut","lockedOut","resetLockout","startLockoutTimer","timeInMinutes","lockoutTimerStarted","timerDuration","timerDurationMins","remainingMins","resetLockoutTimer","renameUserAccount","oldName","newName","confirmPassword","confirmPasswordDisabled","disabled","$","hasBeenValidated","hasError","idleTimeoutMins","configureTimeout","durationMins"],"mappings":";;;;AAAA,SAASA,MAAT,EAAiBC,QAAjB,QAAmD,MAAnD;AAKA,SAASC,UAAT,EAAqBC,SAArB,QAAsC,WAAtC;AACA,SAASC,aAAT,QAA8B,yBAA9B;IAEMC,c,aAAN,MAAMA,cAAN,CAAqB;AACnBC,EAAAA,WAAW,CACDC,MADC,EAEDC,iBAFC,EAGDC,QAHC,EAIT;AAAA,SAHQF,MAGR,GAHQA,MAGR;AAAA,SAFQC,iBAER,GAFQA,iBAER;AAAA,SADQC,QACR,GADQA,QACR;AAAA,SA+KFC,mBA/KE,GA+KoB,IAAIP,SAAJ,CAAc;AAClCQ,MAAAA,oBAAoB,EAAE,IAAIT,UAAJ,CAAuB,EAAvB,EAA2BU,UAA3B,CAAsCR,aAAtC;AADY,KAAd,CA/KpB;AAAE;;AAEgB,QAAdS,cAAc,CAACC,QAAD,EAAmB;AACrC,UAAM,KAAKP,MAAL,CAAYQ,WAAZ,CACJ,KAAKP,iBAAL,CAAuBK,cAAvB,CAAsCC,QAAtC,CADI,CAAN;AAGD;;AAEsB,QAAjBE,iBAAiB,CACrBC,IADqB,EAErBC,eAFqB,EAGrBC,SAHqB,EAIrBC,QAJqB,EAKrB;AACA,WAAO,KAAKZ,iBAAL,CAAuBQ,iBAAvB,CACLC,IADK,EAELC,eAFK,EAGLC,SAHK,EAILC,QAJK,CAAP;AAMD;;AAEsB,QAAjBC,iBAAiB,CAACJ,IAAD,EAAe;AACpC,WAAO,KAAKT,iBAAL,CAAuBa,iBAAvB,CAAyCJ,IAAzC,CAAP;AACD;;AAEmB,QAAdK,cAAc,CAACC,UAAD,EAAqBC,QAArB,EAAuC;AACzD;AACA;AACA;AACA,UAAMC,GAAG,GAAG,KAAKhB,QAAL,CAAciB,YAAd,CAA2BC,MAAvC;;AAEA,QACEJ,UAAU,GAAG,CAAb,IACAC,QAAQ,GAAG,CADX,IAEAD,UAAU,IAAIE,GAFd,IAGAD,QAAQ,IAAIC,GAJd,EAKE;AACA,YAAM,IAAIG,KAAJ,CAAU,sBAAV,CAAN;AACD;;AACD,QAAIL,UAAU,KAAKC,QAAnB,EAA6B;AAC3B;AACD;;AAED,UAAMK,OAAO,GAAG,KAAKpB,QAAL,CAAciB,YAAd,CAA2BI,eAA3B,CAA2CP,UAA3C,EAAuD,CAAvD,CAAhB;AACA,SAAKd,QAAL,CAAciB,YAAd,CAA2BI,eAA3B,CAA2CN,QAA3C,EAAqD,CAArD,EAAwDK,OAAxD;AACA,WAAO,KAAKrB,iBAAL,CAAuBc,cAAvB,CAAsCC,UAAtC,EAAkDC,QAAlD,CAAP;AACD;;AAEDO,EAAAA,eAAe,CAACC,WAAD,EAAsB;AACnC,WAAO,KAAKxB,iBAAL,CAAuBuB,eAAvB,CAAuCC,WAAvC,CAAP;AACD;;AAGe,MAAZN,YAAY,GAAuC;AACrD,WAAO,KAAKjB,QAAL,CAAciB,YAArB;AACD;;AAG0B,MAAvBO,uBAAuB,GAAY;AACrC,WAAO,KAAKxB,QAAL,CAAcwB,uBAArB;AACD;;AAGyB,QAApBC,oBAAoB,GAAG;AAC3B,WAAO,MAAM,KAAK1B,iBAAL,CAAuB0B,oBAAvB,EAAb;AACD;;AAEe,QAAVC,UAAU,CAACC,KAAD,EAAgB;AAC9B,WAAO,MAAM,KAAK5B,iBAAL,CAAuB2B,UAAvB,CAAkCC,KAAlC,CAAb;AACD;;AAEqB,QAAhBC,gBAAgB,CAACD,KAAD,EAAgB;AACpC;AACA,SAAK5B,iBAAL,CAAuB8B,mBAAvB,CAA2CF,KAA3C;AACD;;AAEsB,QAAjBG,iBAAiB,GAAG;AACxB,QAAIC,WAAW,GAAG,MAAM,KAAKhC,iBAAL,CAAuBiC,oBAAvB,EAAxB,CADwB,CAExB;;AACA,SAAKJ,gBAAL,CAAsBG,WAAW,CAACJ,KAAlC;AACD;;AAE0B,QAArBM,qBAAqB,GAAG;AAC5B,WAAO,MAAM,KAAKlC,iBAAL,CAAuBkC,qBAAvB,EAAb;AACD;;AAEyB,QAApBC,oBAAoB,GAAG;AAC3B,WAAO,MAAM,KAAKnC,iBAAL,CAAuBmC,oBAAvB,EAAb;AACD;;AAE2B,QAAtBC,sBAAsB,CAACR,KAAD,EAAgB;AAC1C,WAAO,MAAM,KAAK5B,iBAAL,CAAuBoC,sBAAvB,CAA8CR,KAA9C,CAAb;AACD;;AAE0B,QAArBS,qBAAqB,CAACT,KAAD,EAAgB;AACzC,WAAO,MAAM,KAAK5B,iBAAL,CAAuBqC,qBAAvB,CAA6CT,KAA7C,CAAb;AACD;;AAES,QAAJU,IAAI,GAAG;AACX,WAAO,KAAKtC,iBAAL,CAAuBsC,IAAvB,EAAP;AACD;;AAEW,QAANC,MAAM,CAACjC,QAAD,EAAmB;AAC7B,WAAO,KAAKN,iBAAL,CAAuBuC,MAAvB,CAA8BjC,QAA9B,CAAP;AACD;;AAGkB,MAAfkC,eAAe,GAAY;AAC7B,WAAO,KAAKvC,QAAL,CAAcuC,eAArB;AACD;;AAGe,QAAVC,UAAU,GAAG;AACjB,WAAO,KAAKzC,iBAAL,CAAuByC,UAAvB,EAAP;AACD;;AAGa,MAAVC,UAAU,GAAY;AACxB,WAAO,KAAKzC,QAAL,CAAc0C,UAArB;AACD;;AAGoB,MAAjBC,iBAAiB,GAAG;AACtB,WAAO,KAAK3C,QAAL,CAAc2C,iBAArB;AACD;;AAG0B,MAAvBC,uBAAuB,GAAG;AAC5B,WAAO,KAAK5C,QAAL,CAAc6C,cAArB;AACD;;AAGc,MAAXC,WAAW,GAAG;AAChB,WAAO,KAAK9C,QAAL,CAAc+C,SAArB;AACD;;AAGiB,QAAZC,YAAY,GAAG;AACnB,WAAO,KAAKjD,iBAAL,CAAuBiD,YAAvB,EAAP;AACD;;AAGsB,QAAjBC,iBAAiB,CAACC,aAAD,EAAwB;AAC7C,WAAO,KAAKnD,iBAAL,CAAuBkD,iBAAvB,CAAyCC,aAAzC,CAAP;AACD;;AAGsB,MAAnBC,mBAAmB,GAAG;AACxB,WAAO,KAAKnD,QAAL,CAAcmD,mBAArB;AACD;;AAGgB,MAAbC,aAAa,GAAG;AAClB,WAAO,KAAKpD,QAAL,CAAcqD,iBAArB;AACD;;AAGgB,MAAbC,aAAa,GAAG;AAClB,WAAO,KAAKtD,QAAL,CAAcsD,aAArB;AACD;;AAGsB,QAAjBC,iBAAiB,GAAG;AACxB,WAAO,KAAKxD,iBAAL,CAAuBwD,iBAAvB,EAAP;AACD;;AAEsB,QAAjBC,iBAAiB,CAACC,OAAD,EAAkBC,OAAlB,EAAmC;AACxD,WAAO,KAAK3D,iBAAL,CAAuByD,iBAAvB,CAAyCC,OAAzC,EAAkDC,OAAlD,CAAP;AACD;;AAEoB,QAAfC,eAAe,CAACtD,QAAD,EAAmB;AACtC,WAAO,KAAKN,iBAAL,CAAuB4D,eAAvB,CAAuCtD,QAAvC,CAAP;AACD;;AAO0B,MAAvBuD,uBAAuB,GAAY;AACrC,QAAIC,QAAQ,GACV,CAAC,KAAK5D,mBAAL,CAAyB6D,CAAzB,CAA2B5D,oBAA3B,CAAgD4D,CAAjD,IACA,CAAC,KAAK7D,mBAAL,CAAyB6D,CAAzB,CAA2B5D,oBAA3B,CAAgD6D,gBADjD,IAEC,KAAK9D,mBAAL,CAAyB6D,CAAzB,CAA2B5D,oBAA3B,CAAgD6D,gBAAhD,IACC,KAAK9D,mBAAL,CAAyB6D,CAAzB,CAA2B5D,oBAA3B,CAAgD8D,QAJpD;AAKA,WAAOH,QAAP;AACD;;AAGkB,MAAfI,eAAe,GAAW;AAC5B,WAAO,KAAKjE,QAAL,CAAciE,eAArB;AACD;;AAEqB,QAAhBC,gBAAgB,CAACC,YAAD,EAAuB;AAC3C,QAAIA,YAAY,KAAK,KAAKF,eAA1B,EAA2C;AAC3C,UAAM,KAAKlE,iBAAL,CAAuBmE,gBAAvB,CAAwCC,YAAxC,CAAN;AACD;;AA1MkB,C,gEA0DlB3E,Q,iKAKAA,Q,yKAKAD,M,iKA4CAC,Q,uJAKAD,M,kJAKAC,Q,yJAKAA,Q,sKAKAA,Q,gKAKAA,Q,qJAKAD,M,2JAKAA,M,kKAKAC,Q,8JAKAA,Q,wJAKAA,Q,4JAKAD,M,sKAiBAC,Q,oKAUAA,Q;AAWH,eAAeI,cAAf","sourcesContent":["import { action, computed, IObservableArray } from 'mobx';\nimport { BackgroundManager } from '../BackgroundManager';\nimport ErrorContainer from './ErrorContainer';\nimport { AppState } from '../../lib/MemStore';\nimport { KeyPairWithAlias } from '../../@types/models';\nimport { FieldState, FormState } from 'formstate';\nimport { valueRequired } from '../../lib/FormValidator';\n\nclass AccountManager {\n  constructor(\n    private errors: ErrorContainer,\n    private backgroundManager: BackgroundManager,\n    private appState: AppState\n  ) {}\n\n  async createNewVault(password: string) {\n    await this.errors.withCapture(\n      this.backgroundManager.createNewVault(password)\n    );\n  }\n\n  async importUserAccount(\n    name: string,\n    secretKeyBase64: string,\n    algorithm: string,\n    backedUp: boolean\n  ) {\n    return this.backgroundManager.importUserAccount(\n      name,\n      secretKeyBase64,\n      algorithm,\n      backedUp\n    );\n  }\n\n  async removeUserAccount(name: string) {\n    return this.backgroundManager.removeUserAccount(name);\n  }\n\n  async reorderAccount(startIndex: number, endIndex: number) {\n    // the data flow is always from background to frontend.\n    // we need do reorder operations on both background and frontend side,\n    // so that UI won't get jitter\n    const len = this.appState.userAccounts.length;\n\n    if (\n      startIndex < 0 ||\n      endIndex < 0 ||\n      startIndex >= len ||\n      endIndex >= len\n    ) {\n      throw new Error('Invalid index number');\n    }\n    if (startIndex === endIndex) {\n      return;\n    }\n\n    const removed = this.appState.userAccounts.spliceWithArray(startIndex, 1);\n    this.appState.userAccounts.spliceWithArray(endIndex, 0, removed);\n    return this.backgroundManager.reorderAccount(startIndex, endIndex);\n  }\n\n  switchToAccount(accountName: string) {\n    return this.backgroundManager.switchToAccount(accountName);\n  }\n\n  @computed\n  get userAccounts(): IObservableArray<KeyPairWithAlias> {\n    return this.appState.userAccounts;\n  }\n\n  @computed\n  get isTimeToSecurityCheckup(): boolean {\n    return this.appState.isTimeToSecurityCheckup;\n  }\n\n  @action\n  async resetSecurityCheckup() {\n    return await this.backgroundManager.resetSecurityCheckup();\n  }\n\n  async isBackedUp(alias: string) {\n    return await this.backgroundManager.isBackedUp(alias);\n  }\n\n  async downloadPemFiles(alias: string) {\n    // Save the secret and public keys to disk.\n    this.backgroundManager.downloadAccountKeys(alias);\n  }\n\n  async downloadActiveKey() {\n    let userAccount = await this.backgroundManager.getActiveUserAccount();\n    // Save the secret and public keys to disk.\n    this.downloadPemFiles(userAccount.alias);\n  }\n\n  async getActivePublicKeyHex() {\n    return await this.backgroundManager.getActivePublicKeyHex();\n  }\n\n  async getActiveAccountHash() {\n    return await this.backgroundManager.getActiveAccountHash();\n  }\n\n  async getPublicKeyHexByAlias(alias: string) {\n    return await this.backgroundManager.getPublicKeyHexByAlias(alias);\n  }\n\n  async getAccountHashByAlias(alias: string) {\n    return await this.backgroundManager.getAccountHashByAlias(alias);\n  }\n\n  async lock() {\n    return this.backgroundManager.lock();\n  }\n\n  async unlock(password: string) {\n    return this.backgroundManager.unlock(password);\n  }\n\n  @computed\n  get hasCreatedVault(): boolean {\n    return this.appState.hasCreatedVault;\n  }\n\n  @action\n  async resetVault() {\n    return this.backgroundManager.resetVault();\n  }\n\n  @computed\n  get isUnLocked(): boolean {\n    return this.appState.isUnlocked;\n  }\n\n  @computed\n  get activeUserAccount() {\n    return this.appState.activeUserAccount;\n  }\n\n  @computed\n  get remainingUnlockAttempts() {\n    return this.appState.unlockAttempts;\n  }\n\n  @computed\n  get isLockedOut() {\n    return this.appState.lockedOut;\n  }\n\n  @action\n  async resetLockout() {\n    return this.backgroundManager.resetLockout();\n  }\n\n  @action\n  async startLockoutTimer(timeInMinutes: number) {\n    return this.backgroundManager.startLockoutTimer(timeInMinutes);\n  }\n\n  @computed\n  get lockoutTimerStarted() {\n    return this.appState.lockoutTimerStarted;\n  }\n\n  @computed\n  get timerDuration() {\n    return this.appState.timerDurationMins;\n  }\n\n  @computed\n  get remainingMins() {\n    return this.appState.remainingMins;\n  }\n\n  @action\n  async resetLockoutTimer() {\n    return this.backgroundManager.resetLockoutTimer();\n  }\n\n  async renameUserAccount(oldName: string, newName: string) {\n    return this.backgroundManager.renameUserAccount(oldName, newName);\n  }\n\n  async confirmPassword(password: string) {\n    return this.backgroundManager.confirmPassword(password);\n  }\n\n  confirmPasswordForm = new FormState({\n    confirmPasswordField: new FieldState<string>('').validators(valueRequired)\n  });\n\n  @computed\n  get confirmPasswordDisabled(): boolean {\n    let disabled =\n      !this.confirmPasswordForm.$.confirmPasswordField.$ ||\n      !this.confirmPasswordForm.$.confirmPasswordField.hasBeenValidated ||\n      (this.confirmPasswordForm.$.confirmPasswordField.hasBeenValidated &&\n        this.confirmPasswordForm.$.confirmPasswordField.hasError);\n    return disabled;\n  }\n\n  @computed\n  get idleTimeoutMins(): number {\n    return this.appState.idleTimeoutMins;\n  }\n\n  async configureTimeout(durationMins: number) {\n    if (durationMins === this.idleTimeoutMins) return;\n    await this.backgroundManager.configureTimeout(durationMins);\n  }\n}\n\nexport default AccountManager;\n"]},"metadata":{},"sourceType":"module"}